#!/usr/bin/env python3

from sys import argv, exit, stderr, stdin
from pathlib import Path
from enum import Enum, auto
from struct import pack, unpack


# Parse module
class EntryType(Enum):
    IMMEDIATE = 0x00
    CSR_OFFSET = 0x01
    LEAF = 0x02
    DIRECTORY = 0x03

    @classmethod
    def check_value(cls, value):
        return value in (item.value for item in cls)

    def __repr__(self):
        return "'" + self.name + "'"


class Ieee1212ConfigRomLexer():
    @classmethod
    def detect_entries(cls, raw):
        entries = {}

        bus_info_length = cls.__detect_bus_info_length(raw)
        entries['bus-info'] = raw[4:4 + bus_info_length]
        raw = raw[4 + bus_info_length:]

        entries['root-directory'] = cls.__detect_directory_entries(raw)

        return entries

    @classmethod
    def __detect_bus_info_length(cls, raw):
        meta = unpack('>I', raw[:4])[0]
        bus_info_quadlet_count = (meta & 0xff000000) >> 24
        # crc_quadlet_count = (meta & 0x00ff0000) >> 16
        # crc = meta & 0x0000ffff
        return bus_info_quadlet_count * 4

    @classmethod
    def __detect_immediate(cls, key, value, raw):
        return value

    @classmethod
    def __detect_csr_offset(cls, key, value, raw):
        return 0xfffff0000000 + value * 4

    @classmethod
    def __detect_leaf_or_directory_length(cls, raw):
        meta = unpack('>I', raw[:4])[0]
        quadlet_count = (meta & 0xffff0000) >> 16
        # crc = meta & 0x0000ffff
        return quadlet_count * 4

    @classmethod
    def __detect_leaf(cls, key, value, raw):
        offset = value * 4
        raw = raw[offset:]
        length = cls.__detect_leaf_or_directory_length(raw)
        return raw[4:4 + length]

    @classmethod
    def __detect_directory(cls, key, value, raw):
        raw = raw[value * 4:]
        return cls.__detect_directory_entries(raw)

    @classmethod
    def __detect_directory_entries(cls, raw):
        # Table 7 - Directory entry types
        type_handles = {
            EntryType.IMMEDIATE: cls.__detect_immediate,
            EntryType.CSR_OFFSET: cls.__detect_csr_offset,
            EntryType.LEAF: cls.__detect_leaf,
            EntryType.DIRECTORY: cls.__detect_directory,
        }
        entries = []

        length = cls.__detect_leaf_or_directory_length(raw)
        raw = raw[4:]

        while length > 0:
            meta = unpack('>I', raw[:4])[0]
            key_type_id = (meta & 0xc0000000) >> 30
            key_id = (meta & 0x3f000000) >> 24
            entry_value = meta & 0x00ffffff

            if not EntryType.check_value(key_type_id):
                raise ValueError('Type {0} is not defined.'.format(key_type_id))
            key_type = EntryType(key_type_id)
            handle = type_handles[key_type]

            entry = [(key_id, key_type), handle(key_id, entry_value, raw)]
            entries.append(entry)

            raw = raw[4:]
            length -= 4

        return entries


class DirectoryContext(Enum):
    VENDOR = auto()
    SPECIFIER = auto()
    BUS_DEPENDENT = auto()
    KEYWORD = auto()


class DescriptorType(Enum):
    TEXTUAL = 0x00
    ICON = 0x01

    @classmethod
    def check_value(cls, value):
        return value in (item.value for item in cls)


#
# Table 16 - Key definitions
#
class KeyType(Enum):
    ROOT = 0x00  # For my convenience.
    DESCRIPTOR = 0x01
    BUS_DEPENDENT_INFO = 0x02
    VENDOR = 0x03
    HARDWARE_VERSION = 0x04
    MODULE = 0x07
    NODE_CAPABILITIES = 0x0c
    EUI_64 = 0x0d
    UNIT = 0x11
    SPECIFIER_ID = 0x12
    VERSION = 0x13
    DEPENDENT_INFO = 0x14
    UNIT_LOCATION = 0x15
    MODEL = 0x17
    INSTANCE = 0x18
    KEYWORD = 0x19
    FEATURE = 0x1a
    MODIFIABLE_DESCRIPTOR = 0x1f
    DIRECTORY_ID = 0x20

    @classmethod
    def check_value(cls, value):
        return value in (item.value for item in cls)


class Ieee1212RootDirectoryParser():
    # Table 16 - Key definitions
    COMMON_KEYS = {
        # key:  (name, available types of parser)
        KeyType.DESCRIPTOR: (EntryType.LEAF,
                             EntryType.DIRECTORY),
        # 0x02 is for root directory only.
        KeyType.VENDOR: (EntryType.IMMEDIATE,
                         EntryType.LEAF,
                         EntryType.DIRECTORY),
        KeyType.HARDWARE_VERSION: (EntryType.IMMEDIATE, ),
        # 0x05-06: reserved.
        # 0x07 is for root directory only.
        # 0x08-0b: reserved.
        # 0x07 is for root directory only.
        KeyType.EUI_64: (EntryType.LEAF, ),
        # 0x0e-10: reserved.
        # 0x11 is for root and instance directory only.
        KeyType.SPECIFIER_ID: (EntryType.IMMEDIATE, ),
        KeyType.VERSION: (EntryType.IMMEDIATE, ),
        KeyType.DEPENDENT_INFO: (EntryType.IMMEDIATE,
                                 EntryType.CSR_OFFSET,
                                 EntryType.LEAF,
                                 EntryType.DIRECTORY, ),
        KeyType.UNIT_LOCATION: (EntryType.LEAF, ),
        KeyType.MODEL: (EntryType.IMMEDIATE, ),
        # 0x18 and 0x19 are for root and instance directory only.
        # 0x21-2f: reserved.
        # 0x11 is for instance and unit directory only.
        # NOTE: keys for extended data are not supported.
        KeyType.MODIFIABLE_DESCRIPTOR: (EntryType.LEAF, ),
        KeyType.DIRECTORY_ID: (EntryType.IMMEDIATE, ),
        # 0x30-37: by bus standard.
    }

    def __init__(self):
        self.__bus_dep_handles = {}
        self.__spec_dep_handles = {}
        self.__vendor_dep_handles = {}
        self.__keyword_dep_handles = {}

    def add_bus_dep_handle(self, name, handle):
        if name not in self.__bus_dep_handles:
            self.__bus_dep_handles[name] = []
        self.__bus_dep_handles[name].append(handle)

    def add_spec_dep_handle(self, spec_id, version, handle):
        specifier = (spec_id, version)
        if specifier not in self.__spec_dep_handles:
            self.__spec_dep_handles[specifier] = []
        self.__spec_dep_handles[specifier].append(handle)

    def add_vendor_dep_handle(self, vendor_id, handle):
        if vendor_id not in self.__vendor_dep_handles:
            self.__vendor_dep_handles[vendor_id] = []
        self.__vendor_dep_handles[vendor_id].append(handle)

    def add_keyword_dep_handle(self, keyword, handle):
        if keyword not in self.__keyword_dep_handles:
            self.__keyword_dep_handles[keyword] = []
        self.__keyword_dep_handles[keyword].append(handle)

    def __parse_immediate(self, key_type, ctx, value):
        # 7.7.7 Node_Capabilities entry
        if key_type == KeyType.NODE_CAPABILITIES:
            if self.__bus_name in self.__bus_dep_handles:
                for handle in self.__bus_dep_handles[self.__bus_name]:
                    data = handle(KeyType.NODE_CAPABILITIES.name, EntryType.IMMEDIATE.name, value)
                    if data:
                        value = data
                        break
        return value

    # 7.5.4.1 Textual descriptors
    def __parse_textual_descriptor(self, raw):
        width_definitions = {
            0x00: 'Fixed one-byte characters',
            0x01: 'Fixed two-byte characters',
            0x02: 'Fixed four-byte characters',
            # 0x03-07: reserved
            0x08: 'Not to be used',
            0x09: 'Variable width characters up to a two byte maximum',
            0x0a: 'Variable width characters up to a four byte maximum',
            # 0x0b-0f: reserved
        }

        meta = unpack('>I', raw[:4])[0]
        width = (meta & 0xf0000000) >> 24
        character_set = (meta & 0x0fff0000) >> 16
        language = meta & 0x0000ffff

        if width not in width_definitions or width != 0x00:
            raise OSError('Width {0} is not supported.'.format(width))

        # character_set == IANA MIBenum
        if character_set != 0:
            return OSError('Character set {0} is not supported.'.format(
                character_set))

        # At present, 'US-ASCII' is supported only.
        if language & 0x8000 or language > 0:
            raise OSError('Language {0} is not supported.'.format(language))

        content = raw[4:].decode('US-ASCII') + '\0'
        return content[:content.find('\0')]

    # 7.5.4.2 Icon descriptor
    def __parse_icon_descriptor(self, raw):
        raise OSError('Icon descriptor is not supported.')

    # 7.5.4 Descriptors
    def __parse_descriptor_leaf(self, raw):
        type_parsers = {
            DescriptorType.TEXTUAL: self.__parse_textual_descriptor,
            DescriptorType.ICON: self.__parse_icon_descriptor,
        }

        meta = unpack('>I', raw[:4])[0]
        descriptor_type = (meta & 0xff000000) >> 24
        specifier_id = meta & 0x00ffffff
        raw = raw[4:]

        if specifier_id == 0x00:
            if not DescriptorType.check_value(descriptor_type):
                raise OSError('Descritpor type {0} is not supported.'.format(descriptor_type))
            type_id = DescriptorType(descriptor_type)
            return type_parsers[type_id](raw)

        if specifier_id in self.__vendor_dep_handles:
            for handle in self.__vendor_dep_handles[specifier_id]:
                elem = handle(KeyType.DESCRIPTOR.value, EntryType.LEAF.name, raw)
                if elem:
                    return elem

        return raw

    def __parse_bus_dependent_info_leaf(self, raw):
        # See explanation of Table 9 – Leaf format specifiers.
        if self.__bus_name in self.__bus_dep_handles:
            for handle in self.__bus_dep_handles[self.__bus_name]:
                elem = handle(KeyType.BUS_DEPENDENT_INFO.value, EntryType.LEAF.name, raw)
                if elem:
                    return elem
        return None

    def __parse_vendor_leaf(self, raw):
        # TODO: handle VENDOR/SPECIFIER_ID in parent directory.
        if self.__vendor_id in self.__vendor_dep_handles:
            for handle in self.__vendor_dep_handles[self.__vendor_id]:
                elem = handle(KeyType.VENDOR.value, EntryType.IMMEDIATE.name, raw)
                if elem:
                    return elem
        return None

    # 7.7.5 Module_Primary_EUI_64
    # 7.7.8 EUI_64 entry
    def __parse_eui_64_leaf(self, raw):
        info = (unpack('>I', raw[:4])[0] << 32) | unpack('>I', raw[4:8])[0]
        return info

    def __parse_dependent_info_leaf(self, raw):
        # TODO: handle VENDOR/SPECIFIER_ID in parent directory.
        if self.__vendor_id in self.__vendor_dep_handles:
            for handle in self.__vendor_dep_handles[self.__vendor_id]:
                elem = handle(KeyType.VENDOR.value, EntryType.IMMEDIATE.name, raw)
                if elem:
                    return elem
        return None

    # 7.7.13 Unit_Location entry
    def __parse_unit_location_leaf(self, raw):
        info = {}

        info['base-address'] = \
            (unpack('>I', raw[:4])[0] << 32) | unpack('>I', raw[4:8])[0]
        raw = raw[4:]
        info['upper-bound'] = \
            (unpack('>I', raw[:4])[0] << 32) | unpack('>I', raw[4:8])[0]
        return info

    # 7.6.5 Keyword leaves
    def __parse_keyword_leaf(self, raw):
        return raw.rstrip('\0').decode('US-ASCII')

    def __parse_modifiable_desc_leaf(self, raw):
        meta = unpack('>I', raw[:4])[0]
        info = {}
        info['max-descriptor-size'] = (meta & 0xffff0000) >> 16
        info['descriptor-address'] = (meta & 0x0000ffff) << 32
        info['descriptor-address'] |= unpack('>I', raw[4:8])[0]
        return info

    def __parse_leaf(self, key_type, ctx, raw):
        leaf_parsers = {
            KeyType.DESCRIPTOR: self.__parse_descriptor_leaf,
            KeyType.BUS_DEPENDENT_INFO: self.__parse_bus_dependent_info_leaf,
            KeyType.VENDOR: self.__parse_vendor_leaf,
            KeyType.MODULE: self.__parse_eui_64_leaf,
            KeyType.EUI_64: self.__parse_eui_64_leaf,
            KeyType.DEPENDENT_INFO: self.__parse_dependent_info_leaf,
            KeyType.UNIT_LOCATION: self.__parse_unit_location_leaf,
            KeyType.KEYWORD: self.__parse_keyword_leaf,
            KeyType.MODIFIABLE_DESCRIPTOR: self.__parse_modifiable_desc_leaf,
        }
        if key_type not in leaf_parsers or not leaf_parsers[key_type]:
            raise OSError('Key {0} is not supported.'.format(key_type))
        return leaf_parsers[key_type](raw)

    def __merge_common_keys(self, defined_keys):
        keys = self.COMMON_KEYS
        if defined_keys:
            keys = dict(keys)
            keys.update(defined_keys)
        return keys

    # 7.5.4 Descriptors
    def __parse_descriptor_directory(self, ctx, key_type, entries):
        # See annotation of Table 16 – Key definitions.
        defined_keys = {
            KeyType.DESCRIPTOR: (EntryType.LEAF,
                                 EntryType.DIRECTORY, ),
            KeyType.MODIFIABLE_DESCRIPTOR: (EntryType.LEAF, ),
        }

        return self.__parse_directory_entries(key_type, ctx, entries, defined_keys)

    # 7.7.1 Bus_Dependent_Info entry
    def __parse_bus_dependent_directory(self, ctx, key_type, entries):
        # See explanation of Table 8 – Key ID allocations
        defined_keys = {
            KeyType.BUS_DEPENDENT_INFO: (EntryType.IMMEDIATE,
                                         EntryType.CSR_OFFSET,
                                         EntryType.LEAF, ),
        }

        ctx = (DirectoryContext.BUS_DEPENDENT, self.__NAME)

        return self.__parse_directory_entries(key_type, ctx, entries, defined_keys)

    # 7.7.3 Vendor_Info entry
    def __parse_vendor_directory(self, ctx, key_type, entries):
        # See explanation of Table 8 – Key ID allocations.
        for entry in entries:
            if entry[0] == (KeyType.SPECIFIER_ID.value, EntryType.IMMEDIATE):
                vendor_id = entry[1]
                break
        else:
            for entry in entries:
                if entry[0] == (KeyType.VENDOR.value, EntryType.IMMEDIATE):
                    vendor_id = entry[1]
                    break
            else:
                vendor_id = self.__vendor_id

        if (ctx[0] != DirectoryContext.VENDOR or ctx[1] == vendor_id):
            ctx = (DirectoryContext.VENDOR, vendor_id)

        return self.__parse_directory_entries(key_type, ctx, entries, self.COMMON_KEYS)

    # 7.7.6 Module_Info entry
    def __parse_module_directory(self, ctx, key_type, entries):
        # See explanation of Table 8 – Key ID allocations.
        for entry in entries:
            if entry[0] == (KeyType.SPECIFIER_ID.value, EntryType.IMMEDIATE):
                vendor_id = entry[1]
                break
        else:
            for entry in entries:
                if entry[0] == (KeyType.VENDOR.value, EntryType.IMMEDIATE):
                    vendor_id = entry[1]
                    break
            else:
                vendor_id = self.__vendor_id

        if (ctx[0] != DirectoryContext.VENDOR or ctx[1] == vendor_id):
            ctx = (DirectoryContext.VENDOR, vendor_id)

        return self.__parse_directory_entries(key_type, ctx, entries, self.COMMON_KEYS)

    # 7.6.4 Feature directories
    def __parse_feature_directory(self, ctx, key_type, entries):
        defined_keys = {
            # name:  (key_type, available types of parser)
            KeyType.SPECIFIER_ID: (EntryType.IMMEDIATE, ),
            KeyType.VERSION: (EntryType.IMMEDIATE, ),
            KeyType.DEPENDENT_INFO: (EntryType.IMMEDIATE,
                                     EntryType.CSR_OFFSET,
                                     EntryType.LEAF,
                                     EntryType.DIRECTORY, ),
        }

        # Mandatory entries are required to decide directory context.
        for entry in entries:
            if entry[0] == (KeyType.SPECIFIER_ID.value, EntryType.IMMEDIATE):
                specifier_id = entry[1]
            elif entry[0] == (KeyType.VERSION.value, EntryType.IMMEDIATE):
                version = entry[1]
                break
        else:
            raise ValueError(
                'Mandatory entries are missing in feature directory.')
        ctx = (DirectoryContext.SPECIFIER, (specifier_id, version))

        keys = self.__merge_common_keys(defined_keys)

        return self.__parse_directory_entries(key_type, ctx, entries, keys)

    # 7.6.3 Unit directories
    def __parse_unit_directory(self, ctx, key_type, entries):
        defined_keys = {
            # name:  (key_type, available types of parser)
            KeyType.VENDOR: (EntryType.IMMEDIATE,
                             EntryType.LEAF,
                             EntryType.DIRECTORY, ),
            KeyType.MODEL: (EntryType.IMMEDIATE, ),
            KeyType.SPECIFIER_ID: (EntryType.IMMEDIATE, ),
            KeyType.VERSION: (EntryType.IMMEDIATE, ),
            KeyType.DEPENDENT_INFO: (EntryType.IMMEDIATE,
                                     EntryType.CSR_OFFSET,
                                     EntryType.LEAF,
                                     EntryType.DIRECTORY, ),
            KeyType.FEATURE: (EntryType.DIRECTORY, ),
        }

        # Mandatory entries are required to decide directory context.
        for entry in entries:
            if entry[0] == (KeyType.SPECIFIER_ID.value, EntryType.IMMEDIATE):
                specifier_id = entry[1]
            elif entry[0] == (KeyType.VERSION.value, EntryType.IMMEDIATE):
                version = entry[1]
                break
        else:
            raise ValueError(
                'Mandatory entries are missing in unit directory.')
        ctx = (DirectoryContext.SPECIFIER, (specifier_id, version))

        keys = self.__merge_common_keys(defined_keys)

        return self.__parse_directory_entries(key_type, ctx, entries, keys)

    # 7.7.12 Dependent_Info entry
    def __parse_dependent_info_directory(self, ctx, key_type, entries):
        # Mandatory entries are required to decide directory context.
        for entry in entries:
            if entry[0] == (KeyType.SPECIFIER_ID.value, EntryType.IMMEDIATE):
                specifier_id = entry[1]
            elif entry[0] == (KeyType.VERSION.value, EntryType.IMMEDIATE):
                version = entry[1]
                ctx = (DirectoryContext.SPECIFIER, (specifier_id, version))
                break
        else:
            # TODO: this is a work around. Precisely, need to decide according
            # to entries in parent directory voluntarily.
            pass

        return self.__parse_directory_entries(key_type, ctx, entries, self.COMMON_KEYS)

    # 7.6.2 Instance directories
    def __parse_instance_directory(self, ctx, key_type, entries):
        defined_keys = {
            # name:  (key_type, available types of parser)
            KeyType.VENDOR: (EntryType.IMMEDIATE,
                             EntryType.LEAF,
                             EntryType.DIRECTORY, ),
            KeyType.KEYWORD: (EntryType.LEAF, ),
            KeyType.FEATURE: (EntryType.DIRECTORY, ),
            KeyType.INSTANCE: (EntryType.DIRECTORY, ),
            KeyType.UNIT: (EntryType.DIRECTORY, ),
            KeyType.MODEL: (EntryType.IMMEDIATE, ),
            KeyType.DEPENDENT_INFO: (EntryType.DIRECTORY, ),
        }

        # Keyword leaf entry can decide the context of content.
        for entry in entries:
            if entry[0] == (KeyType.KEYWORD, EntryType.LEAF):
                keyword = self.__parse_leaf(entry[0][0], ctx, entry[1])
                ctx = (DirectoryContext.KEYWORD, keyword)
                break

        keys = self.__merge_common_keys(defined_keys)

        return self.__parse_directory_entries(key_type, ctx, entries, keys)

    def __parse_directory(self, key_type, ctx, entries):
        directory_parsers = {
            KeyType.DESCRIPTOR: self.__parse_descriptor_directory,
            KeyType.BUS_DEPENDENT_INFO: self.__parse_bus_dependent_directory,
            KeyType.VENDOR: self.__parse_vendor_directory,
            KeyType.MODULE: self.__parse_module_directory,
            KeyType.FEATURE: self.__parse_feature_directory,
            KeyType.UNIT: self.__parse_unit_directory,
            KeyType.DEPENDENT_INFO: self.__parse_dependent_info_directory,
            KeyType.INSTANCE: self.__parse_instance_directory,
        }

        return directory_parsers[key_type](ctx, key_type, entries)

    def __parse_directory_entries(self, dir_key_type, ctx, entries, keys):
        type_parsers = {
            EntryType.IMMEDIATE: self.__parse_immediate,
            EntryType.CSR_OFFSET: lambda key_type, ctx, raw: raw,
            EntryType.LEAF: self.__parse_leaf,
            EntryType.DIRECTORY: self.__parse_directory,
        }
        external_handles = {
            DirectoryContext.VENDOR: self.__vendor_dep_handles,
            DirectoryContext.SPECIFIER: self.__spec_dep_handles,
            DirectoryContext.BUS_DEPENDENT: self.__bus_dep_handles,
            DirectoryContext.KEYWORD: self.__keyword_dep_handles,
        }
        info = []

        for entry in entries:
            key = entry[0]
            data = entry[1]
            parser = type_parsers[key[1]]

            key_type = KeyType(key[0]) if KeyType.check_value(key[0]) else None

            if key_type in keys and key[1] in keys[key_type]:
                elem = [key_type.name, parser(key_type, ctx, data)]
            else:
                ctx_name, ctx_value = ctx
                if ctx_value not in external_handles[ctx_name]:
                    elem = entry
                else:
                    for handle in external_handles[ctx_name][ctx_value]:
                        elem = handle(key[0], key[1].name, data)
                        if elem:
                            break
                    else:
                        elem = entry

            info.append(elem)

        return info

    def parse_root_directory(self, bus_name, entries):
        defined_keys = {
            # key_type:  available types of parser
            KeyType.BUS_DEPENDENT_INFO: (EntryType.IMMEDIATE,
                                         EntryType.CSR_OFFSET,
                                         EntryType.LEAF, ),
            KeyType.VENDOR: (EntryType.IMMEDIATE,
                             EntryType.LEAF,
                             EntryType.DIRECTORY, ),
            KeyType.HARDWARE_VERSION: (EntryType.IMMEDIATE, ),
            KeyType.MODULE: (EntryType.LEAF,
                             EntryType.DIRECTORY, ),
            KeyType.NODE_CAPABILITIES: (EntryType.IMMEDIATE, ),
            KeyType.INSTANCE: (EntryType.DIRECTORY, ),
            KeyType.UNIT: (EntryType.DIRECTORY, ),
            KeyType.MODEL: (EntryType.IMMEDIATE, ),
            KeyType.DEPENDENT_INFO: (EntryType.DIRECTORY, ),
            # Node_Unique_ID was obsoleted.
        }

        # Mandatory entries are required to decide directory context.
        for entry in entries:
            if entry[0] == (KeyType.VENDOR.value, EntryType.IMMEDIATE):
                self.__vendor_id = entry[1]
                break
        else:
            raise ValueError('Mandatory entry is missing in root directory.')
        ctx = (DirectoryContext.VENDOR, self.__vendor_id)

        self.__bus_name = bus_name

        keys = self.__merge_common_keys(defined_keys)

        return self.__parse_directory_entries(KeyType.ROOT, ctx, entries, keys)


class Ieee1394ConfigRomParser():
    __BUS_NAME = 0x31333934

    # added by IEEE 1394:1995
    __BUS_CAPS_1995 = {
        'irmc': (0x80000000, 31),  # Isochronous resource manager capable.
        'cmc': (0x40000000, 30),  # cycle master capable.
        'isc': (0x20000000, 29),  # isochronous capable.
        'bmc': (0x10000000, 28),  # bus namager capable.
        'cyc-clk-acc': (0x00ff0000, 16),  # cycle clock accuracy.
        'max_rec': (0x0000f000, 12),  # maximum data record size.
    }

    # added by IEEE 1394a:2000
    __BUS_CAPS_2000 = {
        'pmc': (0x08000000, 28),  # power manager capable.
        'gen': (0x000000c0, 6),  # generation.
        'link-spd': (0x00000007, 0),  # link speed.
    }

    # added by IEEE 1394:2008
    __BUS_CAPS_2008 = {
        'adj': (0x04000000, 27),  # compliant to IEEE 1394.1:2004.
    }

    @classmethod
    def parse_bus_info(cls, raw):
        meta = unpack('>I', raw[:4])[0]
        if meta != cls.__BUS_NAME:
            raise ValueError('The bus_name field mismatch')

        bus_info = {}
        meta = unpack('>I', raw[4:8])[0]

        for caps in (cls.__BUS_CAPS_1995, cls.__BUS_CAPS_2000, cls.__BUS_CAPS_2008):
            for key, (mask, shift) in caps.items():
                bus_info[key] = (meta & mask) >> shift

        meta = unpack('>I', raw[8:12])[0]
        bus_info['node-vendor-id'] = (meta & 0xffffff00) >> 8
        bus_info['chip-id'] = ((meta & 0x000000ff) << 32) | unpack('>I', raw[12:16])[0]

        return bus_info

    # IEEE 1394:1995 refers to ISO/IEC 13213:1994 (ANSI/IEEE Std 1212:1994).
    __NODE_CAPABILITIES = {
        'misc': {
            'spt': (0x008000, 15),  # The SPLIT_TIMEOUT register is implemented.
            'ms': (0x004000, 14),  # The messages-passing registers are implemented.
            'int': (0x002000, 13),  # The INTERRUPT_TARGET and INTERRUPT_MASK registers are implemented.
        },
        'testing': {
            'ext': (0x001000, 12),  # The ARGUMENT registers are implemented.
            'bas': (0x000800, 11),  # Node implements TEST_START&TEST_STATUS registers and testing state.
        },
        'addressing': {
            'prv': (0x000400, 10),  # The node implements the private space.
            '64': (0x000200, 9),  # The node uses 64-bit aaddressing (otherwise 32-bit addressing).
            'fix': (0x000100, 8),  # The node uses the fixed addressing scheme (otherwise extended addressing).
        },
        'state': {
            'lst': (0x000080, 7),  # The STATE_BITS.lost bit is implemented.
            'drq': (0x000040, 6),  # The STATE_BITS.dreq bit is implemented.
            'elo': (0x000020, 4),  # The STATE_BITS.elog bit and the ERROR_LOG registers are implementd.
            'atn': (0x000008, 3),  # The STATE_BITS.atn bit is implemented.
            'off': (0x000004, 2),  # The STATE_BITS.off bit is implemented.
            'ded': (0x000002, 1),  # The node supports the dead state.
            'init': (0x000001, 0),  # The node supports the initializing state.
        },
    }

    @classmethod
    def parse_node_caps(cls, val):
        node_caps = {}
        for category, caps in cls.__NODE_CAPABILITIES.items():
            if category not in node_caps:
                node_caps[category] = {}
            for key, (mask, shift) in caps.items():
                node_caps[category][key] = (val & mask) >> shift

        return node_caps


class ModaliasGenerator:
    @classmethod
    def generate(cls, filename, bus_info, root_directory, verbose):
        node_attrs = cls.__emulate_node_attrs(bus_info, root_directory)

        units_attrs = []
        if 'units' in node_attrs:
            for (key_type, key_value) in root_directory:
                if key_type == 'UNIT':
                    units_attrs.append(cls.__emulate_unit_attrs(key_value))

        if len(units_attrs) > 0:
            for i, unit_attrs in enumerate(units_attrs):
                node_key = cls.__generate_custom_node_key(node_attrs, i)
                modalias = cls.__generate_unit_modalias(node_attrs, unit_attrs)
                data = cls.__generate_unit_data(node_attrs, unit_attrs)

                print('')
                if len(units_attrs) > 1:
                    print('# generated with {} for unit {}'.format(filename, i))
                else:
                    print('# generated with {}'.format(filename))
                print(node_key)
                print(modalias)
                for key, value in data.items():
                    print('  {}={}'.format(key, value))
        else:
            print('This node includes no unit.')

        if verbose:
            print('')
            cls.__print_attrs(node_attrs, units_attrs)

    # I decide it for hwdb of systemd. Two types of format are used depending on cases.
    @classmethod
    def __generate_custom_node_key(cls, attrs, unit_index):
        if 'units' in attrs:
            units = attrs['units'].split(' ')
            if len(units) == 1:
                unit = 'units{}'.format(units[unit_index])
            else:
                unit = 'units*{}*'.format(units[unit_index])
        else:
            unit = ''

        if 'model' in attrs:
            model = 'mo{}'.format(attrs['model'])
        else:
            model = ''
        return 'ieee1394:node:ven{}{}{}'.format(attrs['vendor'], model, unit)

    # Linux FireWire subsystem decides.
    @classmethod
    def __generate_unit_modalias(cls, node_attrs, unit_attrs):
        ven = 0
        for attrs in (unit_attrs, node_attrs):
            if 'vendor' in attrs:
                ven = int(attrs['vendor'], 16)

        mo = 0
        for attrs in (unit_attrs, node_attrs):
            if 'model' in attrs:
                mo = int(attrs['model'], 16)

        spec = 0
        if 'specifier_id' in unit_attrs:
            spec = int(unit_attrs['specifier_id'], 16)

        ver = 0
        if 'version' in unit_attrs:
            ver = int(unit_attrs['version'], 16)

        return 'ieee1394:ven{:08X}mo{:08X}spec{:08X}ver{:08X}'.format(ven, mo, spec, ver)

    @classmethod
    def __generate_unit_data(cls, node_attrs, unit_attrs):
        iidc_pairs = (
            ('0x00a02d', '0x000100'),  # IIDC v1.04
            ('0x00a02d', '0x000101'),  # IIDC v1.20
            ('0x00a02d', '0x000102'),  # IIDC v1.30, v1.31, v1.32
            ('0x00a02d', '0x000110'),  # IIDC2 v1.00
        )
        pgrey_pairs = (
            ('0x00b09d', '0x000100'),
            ('0x00b09d', '0x000101'),
            ('0x00b09d', '0x000102'),
        )

        data = {}

        data['VENDOR_ID_FROM_DATABASE'] = '(fill this entry!)'
        for attrs in (node_attrs, unit_attrs):
            if 'vendor_name' in attrs and isinstance(attrs['vendor_name'], str):
                data['VENDOR_ID_FROM_DATABASE'] = attrs['vendor_name']

        data['MODEL_ID_FROM_DATABASE'] = '(fill this entry!)'
        for attrs in (node_attrs, unit_attrs):
            if 'model_name' in attrs and isinstance(attrs['model_name'], str):
                data['MODEL_ID_FROM_DATABASE'] = attrs['model_name']

        data['FW_UNIT_TYPE'] = '(fill this entry!)'
        if 'specifier_id' in unit_attrs and 'version' in unit_attrs:
            unit_pair = (unit_attrs['specifier_id'], unit_attrs['version'])
            if unit_pair == ('0x00a02d', '0x010001'):
                data['FW_UNIT_TYPE'] = '(select from video or audio_and_music)'
            elif unit_pair == ('0x00a02d', '0x014001'):
                data['FW_UNIT_TYPE'] = '(select from video or audio_and_music)'
            else:
                for pairs in (iidc_pairs, pgrey_pairs):
                    for pair in pairs:
                        if pair == unit_pair:
                            data['FW_UNIT_TYPE'] = 'video'

        return data

    @classmethod
    def __print_attrs(cls, node_attrs, units_attrs):
        print('Attributes emulated for Linux FireWire subsystem:')

        print('  Node attributes:')
        for key, value in node_attrs.items():
            print('    ATTR{{{}}}=="{}"'.format(key, value))
        for i, unit_attrs in enumerate(units_attrs):
            print('  Unit {} attributes:'.format(i))
            for key, value in unit_attrs.items():
                print('    ATTR{{{}}}=="{}"'.format(key, value))

    @classmethod
    def __emulate_node_attrs(cls, bus_info, root_directory):
        attrs = {}

        attrs['guid'] = '0x{:06x}{:012x}'.format(bus_info['node-vendor-id'], bus_info['chip-id'])

        vendor_flag = False
        model_flag = False
        units = []
        for key_type, key_value in root_directory:
            if key_type == 'VENDOR':
                attrs['vendor'] = '0x{:06x}'.format(key_value)
                vendor_flag = True
            elif key_type == 'MODEL':
                attrs['model'] = '0x{:06x}'.format(key_value)
                model_flag = True
            elif key_type == 'DESCRIPTOR':
                if vendor_flag:
                    attrs['vendor_name'] = key_value
                    vendor_flag = False
                elif model_flag:
                    attrs['model_name'] = key_value
                    model_flag = False
            elif key_type == 'UNIT':
                specifier_id = None
                version = None
                for (unit_key_type, unit_key_value) in key_value:
                    if unit_key_type == 'SPECIFIER_ID':
                        specifier_id = unit_key_value
                    elif unit_key_type == 'VERSION':
                        version = unit_key_value
                if specifier_id is not None and version is not None:
                    units.append('0x{:06x}:0x{:06x}'.format(specifier_id, version))

        if len(units):
            attrs['units'] = ' '.join(units)

        return attrs

    @classmethod
    def __emulate_unit_attrs(cls, entries):
        attrs = {}
        model_name_flag = False
        for (key_type, key_value) in entries:
            if key_type == 'SPECIFIER_ID':
                attrs['specifier_id'] = '0x{:06x}'.format(key_value)
            elif key_type == 'VERSION':
                attrs['version'] = '0x{:06x}'.format(key_value)
            elif key_type == 'MODEL':
                attrs['model'] = '0x{:06x}'.format(key_value)
                model_name_flag = True
            elif key_type == 'DESCRIPTOR' and model_name_flag:
                attrs['model_name'] = key_value
                model_name_flag = False
        return attrs


if len(argv) < 2:
    print('modalias-generator PATH [VERBOSE]')
    print('  PATH: path to file of image for configuration ROM')
    print('  VERBOSE: any value for verbose output to print emulated sysfs attribute')
    exit(1)

path = Path(argv[1])
verbose = len(argv) > 2

if not path.exists():
    print('{} not exists'.format(path.name))
    exit(1)

if path.is_dir():
    print('{} is not path to file'.format(path.name))
    exit(1)

raw = []
with path.open('rb') as f:
    data = f.read()
    if len(data) < 4:
        print('{} has no content'.format(path.name))
        exit(1)

    # The parser is written for quadlet-aligned big-endian data.
    endian_check = unpack('>I', data[4:8])[0]
    if endian_check == 0x34393331:
        raw = bytearray()
        for pos in range(0, len(data), 4):
            val = unpack('<I', data[pos:(pos + 4)])[0]
            raw.extend(pack('>I', val))
    else:
        raw = data

rom = Ieee1212ConfigRomLexer.detect_entries(raw)

bus_info = Ieee1394ConfigRomParser.parse_bus_info(rom['bus-info'])

parser = Ieee1212RootDirectoryParser()
entries = parser.parse_root_directory('1394', rom['root-directory'])

ModaliasGenerator.generate(path.name, bus_info, entries, verbose)
